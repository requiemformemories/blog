<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="/blog/tag/sql/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/blog/" rel="alternate" type="text/html" />
  <updated>2023-11-19T23:48:53+08:00</updated>
  <id>/blog/tag/sql/feed.xml</id>

  
  
  

  
    <title type="html">Fumitsuki’s magic box | </title>
  

  
    <subtitle>keep calm and eat eight Plates.</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">工作雜談：多餘的 DB 欄位跟關聯</title>
      <link href="/blog/single-source-of-truth-and-event-sourcing" rel="alternate" type="text/html" title="工作雜談：多餘的 DB 欄位跟關聯" />
      <published>2022-06-23T18:23:00+08:00</published>
      <updated>2022-06-23T18:23:00+08:00</updated>
      <id>/blog/single-source-of-truth-and-event-sourcing</id>
      <content type="html" xml:base="/blog/single-source-of-truth-and-event-sourcing">&lt;p&gt;最近在工作上遇到很困擾的事情之一，就是在資料的架構上，前人建了很多重複、多餘的關聯跟欄位。&lt;/p&gt;

&lt;h2 id=&quot;多餘的關聯&quot;&gt;多餘的關聯&lt;/h2&gt;

&lt;p&gt;例如系統中有很多使用者（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users&lt;/code&gt;），每個使用者一定會屬於一間店家（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stores&lt;/code&gt;），但這些店家之間不會共用使用者資料，使用者上會有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store_id&lt;/code&gt; 欄位去紀錄這個多對一的關聯。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-order-store.png&quot; alt=&quot;DB diagram of orders and stores&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接者，每個使用者都有他綁定的支付方式（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;payment_methods&lt;/code&gt;），一個支付方式只屬於一位使用者，沒有共用的狀況。支付方式上會有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt; 紀錄他屬於哪一個使用者。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-store-order-payment_method.png&quot; alt=&quot;DB diagram of orders, stores, and payment-methods&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果今天我想在支付方式列表上看見這是哪個店家底下的支付方式，我應該會從支付方式找到關聯的使用者，再找到所屬的店家。但前人可能覺得「一直 JOIN 好麻煩哪」之類的，於是錢包上也多了一個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store_id&lt;/code&gt; 去紀錄關聯到的店家。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-storeid-redundant.png&quot; alt=&quot;DB diagram with redundant store_id&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整個資料庫多了好幾條關聯看起來都是為了少幾條 JOIN 建的，卻搞得撈資料的人不知道多個來源到底哪一個才是對的。這個時候如果錢包的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store_id&lt;/code&gt; 跟所屬 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 身上的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store_id&lt;/code&gt; 不同的時候，就會相當懊惱我到底該相信誰。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-user-payment-method-problem.png&quot; alt=&quot;store_ids are not same&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;多餘的欄位&quot;&gt;多餘的欄位&lt;/h2&gt;

&lt;p&gt;舉例來說，訂單（orders）底下會有很多刷卡紀錄（payments）。例如訂單有可能刷卡失敗，最後終於刷成功時，整張訂單才算是付款成功了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-order-payment.png&quot; alt=&quot;DB diagram with orders and payments&quot; /&gt;&lt;/p&gt;

&lt;p&gt;或者是，訂單可能會有退款紀錄，可能部分退款，也可能是全額退款。可能退款 10 元，也可能退款 20 元。訂單上有付款狀態（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;payment_state&lt;/code&gt;）、退款金額（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refund_amount&lt;/code&gt;）這樣的欄位在紀錄付款結果、退款金額。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-order-payment-problem.png&quot; alt=&quot;payment_state and refund_amount are not same&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原本另開欄位可能是圖個方便直接拿欄位的數值來使用，但當 code 寫爛了的時候，就會發生一些狀態不一致，不知道哪個欄位才是正確的問題。例如，當付款狀態（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;payment_state&lt;/code&gt;）是的「訂單等待付款（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending&lt;/code&gt;）」，但訂單卻有付款成功的紀錄時，我應該相信誰？如果訂單有一筆成功退 10 元的退款紀錄，但這筆訂單的退款金額（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refund_amount&lt;/code&gt;）卻還是 0 的時候，是不是我拿訂單的退款金額（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refund_amount&lt;/code&gt;）去做後續的判斷跟分析時，會大錯特錯？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-order-payment2.png&quot; alt=&quot;DB diagram with orders and payments, and there are payment_state and refund_amount on orders&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;single-source-of-truth&quot;&gt;Single Source of Truth&lt;/h2&gt;

&lt;p&gt;關於以上的例子，第一個想要談談的概念是 Single Source of Truth。單一事實來源（Single Source of Truth，SSOT）大致上的意思是說，資料應該要由同一個來源讀取跟計算數值。&lt;/p&gt;

&lt;p&gt;在以上讓我困擾的例子中，很大的問題是我會有兩個以上的 data source，讓我不知道應該要依循哪一個。如果今天寫 SQL 時是用 A 來源，同事卻是用 B 來源，有可能資料不一致時會帶來錯誤跟困擾。&lt;/p&gt;

&lt;h2 id=&quot;event-sourcing&quot;&gt;Event Sourcing&lt;/h2&gt;

&lt;p&gt;再來看看付款紀錄的例子，其實，付款狀態可以用這張訂單的「付款紀錄」的狀態去獲得，例如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有付款成功的付款紀錄 =&amp;gt; 訂單付款成功&lt;/li&gt;
  &lt;li&gt;沒有任何付款紀錄 =&amp;gt; 訂單等待付款&lt;/li&gt;
  &lt;li&gt;有付款紀錄但沒有付款成功的 payment =&amp;gt; 訂單付款過但失敗了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;退款金額在可以直接用訂單底下的退款紀錄去得到目前退過多少錢，把退款成功的退款紀錄的金額加總，就會是目前退款的金額。&lt;/p&gt;

&lt;p&gt;我覺得會是用類似 event sourcing 的方式來得到訂單的付款狀態跟資訊，每個付款紀錄、退款紀錄其實相當於一個個 event，將這些 event aggregate 起來，我就可以拿到當前訂單的狀態。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/20220623-event-sourcing.png&quot; alt=&quot;event sourcing&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;performance&lt;/h2&gt;

&lt;p&gt;我覺得前人的架構之所以會設計成這樣，可能是有 SQL 效能上的迷思。例如，如果把一些需要 JOIN 兩次以上的關聯變成 JOIN 一次就好，是不是就可以讓 SQL 效能變好了？或者是原本需要關聯到 payments 去看付款狀態跟退款金額的方式需要 JOIN payments 這張表，如果把我要的資訊放在 orders 的欄位上是不是可以少一個 JOIN 造成的負擔？&lt;/p&gt;

&lt;p&gt;但我自己覺得這會是很大的效能迷思。首先，如果 JOIN 了資料，下了 WHERE，結果資料撈很久，應該先 EXPLAIN 一下，看看 SQL 到底慢在哪裡。常常很大一部分都是沒有 index，沒吃到 index 造成的問題。沒有吃到 index 的時候，資料庫可能會用逐行掃描的方式 seq scan 過整張表去找資料，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; Seq Scan on orders (cost=0.00..504250.77 rows=11831677 width=267)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;加好了 index 以後，如果撈取資料時有正常吃到 index，會使用 index scan 的方式去撈資料。在資料量大的時候，效能的差異會有很明顯的差別。我會覺得如果覺得 JOIN 表時， SQL 就變得好慢，應該先檢查一下 foreign key 跟 WHERE 使用的欄位有沒有好好的下到 index。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; Index Scan using index_payments_on_order_id on payments (cost=0.43..5.80 rows=1 width=1376)
Index Cond: (order_id = orders.id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 DB 的架構設計上，我覺得真的是特別需要深思熟慮的事情，後續要再盤點欄位的意義、被如何使用，甚至要想試著進行搬移整併的話都會相當困難QQ&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>文月</name>
        
        
      </author>

      

      
        <category term="sql" />
      

      
        <summary type="html">最近在工作上遇到很困擾的事情之一，就是在資料的架構上，前人建了很多重複、多餘的關聯跟欄位。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[SQL] 為什麼要多一張表處理多對多關係？把數值都逗號分隔存起來不行嗎？</title>
      <link href="/blog/sql-no-comma-seperated-list" rel="alternate" type="text/html" title="[SQL] 為什麼要多一張表處理多對多關係？把數值都逗號分隔存起來不行嗎？" />
      <published>2020-04-29T14:13:00+08:00</published>
      <updated>2020-04-29T14:13:00+08:00</updated>
      <id>/blog/sql-no-comma-seperated-list</id>
      <content type="html" xml:base="/blog/sql-no-comma-seperated-list">&lt;p&gt;想當初小的在學校學 SQL 的時候，從來沒有仔細想過為什麼的多對多關聯都要再多用一個 table 來處理。&lt;/p&gt;

&lt;p&gt;如果直接把資料想辦法塞在一個欄位裡，比方說在 table &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users&lt;/code&gt; 上新增 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orders&lt;/code&gt; 欄位（type 為 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VARCHAR&lt;/code&gt;），把 order_id 們像是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1, 34, 135&lt;/code&gt; 這樣地塞在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orders&lt;/code&gt;欄位中，不是也可以嗎？（或是反過來新增 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users&lt;/code&gt; 欄位在資料表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orders&lt;/code&gt; 上）&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;….&lt;/th&gt;
      &lt;th&gt;orders&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Grace&lt;/td&gt;
      &lt;td&gt;….&lt;/td&gt;
      &lt;td&gt;2, 14, 65, 11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;….&lt;/td&gt;
      &lt;td&gt;3, 2, 1, 12, 100&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;乍聽之下，這個想法真是聰明，這樣就可以省得新增一個表格呢！&lt;/p&gt;

&lt;p&gt;但是今天就要為大家破除這個迷思，一但試了一次這個方法，&lt;strong&gt;未來恐怕後患無窮&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未來恐怕後患無窮&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未來恐怕後患無窮&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因為很重要所以說三次（咦）&lt;/p&gt;

&lt;p&gt;大家務必三思以後再考慮這樣設計 schema 呢。&lt;/p&gt;

&lt;h2 id=&quot;problem-1-當我想要在-users-裡-where-order_id--11卻發現行不通&quot;&gt;Problem 1: 當我想要在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users&lt;/code&gt; 裡 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE order_id = 11&lt;/code&gt;，卻發現行不通。&lt;/h2&gt;

&lt;p&gt;如果我&lt;del&gt;沒有採用這大膽的想法&lt;/del&gt;乖乖地把 user 跟 order 用另一張表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_orders&lt;/code&gt; 來整理他們之間的多對多關係，就可以像這樣查找 id 為 11 的 order 對應到哪些 user：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_orders&lt;/span&gt;
                          &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但如果今天是上面那個存 comma-seperated list 的做法呢？&lt;/p&gt;

&lt;p&gt;這個時候只好改寫醜一點的 SQL query 來查找你要的 users，比方說想辦法用 REGEXP 去 match 它：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGEXP&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[[:&amp;lt;:]]11[[:&amp;gt;:]]'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一方面要提心吊膽自己的 REGEXP 沒寫法，會 match 到不該 match 的，另一方面還要擔心資料有不符合規範的東西，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1, 2, 4, 11aaaa, 12&lt;/code&gt; 等等。自己 match 資料時出錯的風險也大大提高。&lt;/p&gt;

&lt;p&gt;除此之外，查找 order_id 的部分也無法加 index 來提升效能。&lt;/p&gt;

&lt;h2 id=&quot;problem-2-很難反過來找使用者的訂單資料&quot;&gt;Problem 2: 很難反過來找使用者的訂單資料&lt;/h2&gt;

&lt;p&gt;接著，如果我今天想要找&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 為 1 的 user 的訂單資料，如果是乖乖新增第三張表的時候，可以簡單地 join table 解決。如果是現在這個 comma-seperated list 的作法，就只好再來寫醜醜的 SQL：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGEXP&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[[:&amp;lt;:]]'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[[:&amp;gt;:]]'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是否開始感覺到為了一時輕率的選擇，造成的後果要用一世來彌補（欸）&lt;/p&gt;

&lt;p&gt;然而問題還沒完，讓我們望向第三個問題。&lt;/p&gt;

&lt;h2 id=&quot;problem-3-不能用sumavg-等等-function-來做-aggregate-queries&quot;&gt;Problem 3: 不能用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVG()&lt;/code&gt; 等等 function 來做 aggregate queries&lt;/h2&gt;

&lt;p&gt;如果今天你想要統計每個使用者有多少訂單，如果是好好地使用第三張表的做法，就可以簡單地使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM()&lt;/code&gt; 來找出訂單數量：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_orders&lt;/span&gt;
                                            &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是用了 comma-seperated list 以後，這些資料不是分開一個 row 一個 row，而是全部擠在某個 user 的一個欄位裡。這個時候要計算訂單數量只好用一些奇妙的方法來解決。&lt;/p&gt;

&lt;p&gt;比方說，如果保證每個使用者一定有對應的帳單的話，就可以透過「逗點的數量」來計算有幾筆訂單。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;12&lt;/code&gt;: 一筆訂單&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;12, 27&lt;/code&gt;: 兩筆訂單&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;12, 27, 33&lt;/code&gt;: 三筆訂單&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;12, 27, 33, 65&lt;/code&gt;: 四筆訂單&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是說，逗點數量 + 1 會是訂單數量。於是就可以透過 (總字數) - (去掉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt; 的字數) 來計算有幾個逗號。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;REPLACE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;','&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;problem-4-順序問題&quot;&gt;Problem 4: 順序問題&lt;/h2&gt;

&lt;p&gt;想到這個 comma-seperated list 的做法的朋友們，可能會想說這個做法最簡單的地方在於，可以簡單地 append 新的 order_id 在欄位的最後面。比方說，id 為 5 的 user 原本的 orders 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11, 14, 18&lt;/code&gt;，如果要建立他跟 id 為 20 帳單的關係，只要在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11, 14, 18&lt;/code&gt; 後面加上逗號與 20 就好，變成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11, 14, 18, 20&lt;/code&gt; 這樣。&lt;/p&gt;

&lt;p&gt;但是如果今天正好要加進來的 id 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;，就會變成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11, 14, 18, 5&lt;/code&gt;，經過日日夜夜的累積，你的 orders 變得順序雜亂。哪天需要照順序的 id 的時候，只好一個 row 一個 row 的資料抓出來排序QQ&lt;/p&gt;

&lt;p&gt;這個時候你或許會想說：「哦哦，那我再把它塞進去資料庫之前，先把新加的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; 放到正確的位置！這樣就沒問題了吧？」&lt;/p&gt;

&lt;p&gt;的確是如此，這個時候必須要跑兩個 query，一個把舊資料撈出來，下一個把你把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; 加好的資料塞回去。只是當初好好地新增一張表，現在就可以用一個 SQL 就新增新的 order_id，查詢時也可以用 ORDER BY 無痛解決排序問題。&lt;/p&gt;

&lt;h2 id=&quot;problem-5-刪除特定-id&quot;&gt;Problem 5: 刪除特定 id&lt;/h2&gt;

&lt;p&gt;再來下一個難題是，該如何刪掉特定的 id 呢？&lt;/p&gt;

&lt;p&gt;一樣要跑兩個 query，一個把資料撈出來，自己寫程式找出 id 在哪，去掉以後再把新字串塞回去。&lt;/p&gt;

&lt;p&gt;開始感覺到做出了錯誤的抉擇，會讓日後的維護很阿雜XD&lt;/p&gt;

&lt;h2 id=&quot;problem-6-資料驗證&quot;&gt;Problem 6: 資料驗證&lt;/h2&gt;

&lt;p&gt;用了 comma-seperated list 的做法以後，因為 order_id 的資料不是一個個 row 獨立存起來的，已經無法透過建立 constraint 來管理資料的正確性與完整性。當 SQL 不再幫你檢驗 constraint，如果程式那邊沒有檢查好，到時候連自己都不會知道欄位被亂塞了什麼東西（eg. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3, 12, 1, banana&lt;/code&gt;）&lt;/p&gt;

&lt;h2 id=&quot;problem-7-seperator-被當成-string-的一部分&quot;&gt;Problem 7: seperator 被當成 string 的一部分&lt;/h2&gt;

&lt;p&gt;假設今天 order_id 有可能使用者自訂的字串，今天有個壞心眼的使用者，把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a,b,c&lt;/code&gt; 當成 order_id。於是這個 user 的 orders 就多了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a,b,c&lt;/code&gt;。當你要解析這個使用者有哪些訂單時，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a,b,c&lt;/code&gt; 就很開心地被解析成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;，然後使用者永遠都無法正常地找回他的資料。&lt;/p&gt;

&lt;p&gt;於是大家可能會開始想，我就用一個正常人不可能拿來用的字元當 seperator 吧！或者是在存入 order_id 時就限制不可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt; 這個字元。的確是可以這樣修正，但如果是功能都開發下去、被使用了才出事，中途搶救也會很麻煩。&lt;/p&gt;

&lt;h2 id=&quot;problem-8長度限制&quot;&gt;Problem 8:長度限制&lt;/h2&gt;
&lt;p&gt;畢竟是用一個欄位來存 order_id 們，就要特別注意長度限制。比方說 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VARCHAR(255)&lt;/code&gt;，如果裡面塞長度為 9 的字串，可以塞到 25 個才會爆炸。於是你只好想辦法說服你的客戶，一個 user 就是不能有太多 order。&lt;/p&gt;

&lt;p&gt;這個時候，你心中的小惡魔可能會冒出來跟你說：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;齁齁齁，有什麼關係，用 TEXT 我可以塞到 65535 bytes 呢 ヽ(́◕◞౪◟◕‵)ﾉ
TEXT 不夠我可以用 LONGTEXT 呀 (☝ ՞ਊ ՞）☝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;拜託….拜託不要亂來（欸&lt;/p&gt;

&lt;p&gt;以上已經提出這種方法的八個疑慮了，就不要再用邪魔歪道與大量 workaround 來處理事情了吧。&lt;/p&gt;

&lt;h2 id=&quot;如何發現這個-antipattern&quot;&gt;如何發現這個 Antipattern&lt;/h2&gt;

&lt;p&gt;當專案小夥伴問你：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;「這個 list 最多會有幾個 entries 呢？」
代表他已經在算 VARCHAR 長度要給多少了 ヽ(́◕◞౪◟◕‵)ﾉ&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;「用 SQL 要怎麼 match word boundary 呢？」
極有可能他正在思量怎麼從 list 裡挑出某個 entry (例子裡的 order_id) &amp;gt;&amp;lt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;「這些 entries 裡會出現哪些符號呢？有什麼絕對不可能出現的特定符號嗎？」
代表他已經在考慮 seperator 要用哪個符號了 (☝ ՞ਊ ՞）☝&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;使用這個-pattern-的合理情況&quot;&gt;使用這個 pattern 的合理情況&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;比方說你有個欄位要顯示 comma-seperated list，你不會需要取這個 list 裡的單一 item，這個時候你可能會考慮反正規化一下，加了欄位放這個 comma-seperated list&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;從別的 source 剛取回來的資料，正好有 comma-seperated list。在你 process 這些資料之前可能會考慮原封不動地存起來。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;解方intersection-table&quot;&gt;解方：intersection table&lt;/h2&gt;

&lt;p&gt;就跟以前學校老師講得一樣（欸
乖乖地新增一個 table 來存其他兩張 table 多對多的關係。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;order_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;補充regexp&quot;&gt;補充：REGEXP&lt;/h2&gt;
&lt;p&gt;參考 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/regexp.html#operator_regexp&quot;&gt;Regular Expressions - MYSQL&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;character_class-character_class&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[=character_class=]&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[:character_class:]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在剛剛內文裡有用到的：&lt;/p&gt;

&lt;h3 id=&quot;-&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[:&amp;lt;:]], [[:&amp;gt;:]]&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;可以用來查找有沒有包含特定字串：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'a word a'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGEXP&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[[:&amp;lt;:]]word[[:&amp;gt;:]]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'a xword a'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGEXP&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[[:&amp;lt;:]]word[[:&amp;gt;:]]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;本文是參考 Bill Karwin 的 SQL Antipatterns 第二章 Jaywalking 彙整而成。原書說明了很多不太好的設計模式，什麼時候可以使用以及為何要避免使用等等。大家有空可以去翻閱看看哦。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>文月</name>
        
        
      </author>

      

      
        <category term="sql" />
      

      
        <summary type="html">想當初小的在學校學 SQL 的時候，從來沒有仔細想過為什麼的多對多關聯都要再多用一個 table 來處理。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[SQL] 什麼要 primary key？primary key 一定要叫 id 嗎？</title>
      <link href="/blog/sql-primary-key" rel="alternate" type="text/html" title="[SQL] 什麼要 primary key？primary key 一定要叫 id 嗎？" />
      <published>2020-04-27T14:13:00+08:00</published>
      <updated>2020-04-27T14:13:00+08:00</updated>
      <id>/blog/sql-primary-key</id>
      <content type="html" xml:base="/blog/sql-primary-key">&lt;h2 id=&quot;問題一可不可以不要-primary-key-沒有-primary-key-會怎樣&quot;&gt;問題一：可不可以不要 primary key？ 沒有 primary key 會怎樣？&lt;/h2&gt;
&lt;p&gt;primary key 主要的作用為：&lt;/p&gt;

&lt;h3 id=&quot;1-避免產生一堆重複又無法識別的-row&quot;&gt;1. 避免產生一堆重複又無法識別的 row&lt;/h3&gt;

&lt;p&gt;例如底下的表格，上一筆跟下一筆長一模一樣，根本無法識別。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;quantity&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;2-有辦法撈到特定的-row&quot;&gt;2. 有辦法撈到特定的 row&lt;/h3&gt;

&lt;p&gt;如下，每個 row 都長一樣，根本無法撈到特定某個 row。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;quantity&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;但是改成這樣：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;quantity&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;就可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE id = 1&lt;/code&gt; 來撈到第一筆資料&lt;/p&gt;

&lt;h3 id=&quot;3-foreign-key-reference&quot;&gt;3. foreign key reference&lt;/h3&gt;

&lt;p&gt;比方說這張表是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orders&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;customer&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;total&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;2020-01-01&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Carl&lt;/td&gt;
      &lt;td&gt;2020-01-01&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;2020-01-06&lt;/td&gt;
      &lt;td&gt;2500&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;有另一張表是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;quantity&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orders&lt;/code&gt; 上沒有 primary key，無法透過在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt; 加上 foreign key 來 reference order。&lt;/p&gt;

&lt;p&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orders&lt;/code&gt; 改成這樣：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;customer&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;total&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;2020-01-01&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Carl&lt;/td&gt;
      &lt;td&gt;2020-01-01&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;2020-01-06&lt;/td&gt;
      &lt;td&gt;2500&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;就可以簡單透過在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt; 上加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_id&lt;/code&gt;，加上 foreign key 來做 reference&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;quantity&lt;/th&gt;
      &lt;th&gt;order_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;沒有 primary key 的資料，就像是沒有書名的書，沒有歌名的音樂（欸）&lt;strong&gt;很容易造成整理上的困難。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;問題二如何選擇-primary-key&quot;&gt;問題二：如何選擇 primary key？&lt;/h2&gt;

&lt;p&gt;primary key 有個必帶條件：一定要是&lt;strong&gt;唯一（unique）&lt;/strong&gt;的，不可以重複。&lt;/p&gt;

&lt;p&gt;所以你通常會找個 unique 的欄位來當 primary key。然而很多大家以為 unique 的東西都沒有 unique，例如身分證字號。（身分證字號在古早年代是有可能不小心重複發的XD）&lt;/p&gt;

&lt;p&gt;或者是你看完 spec 以後以為應該要 unique，結果哪一天老闆跑來跟你說：「這個欄位的內容可以重複嗎？」的資料。（這個時候都會 OS：要不是我還不能離職，要不然真想打扁你XD）&lt;/p&gt;

&lt;p&gt;像是使用者的 email、電話等等。&lt;/p&gt;

&lt;p&gt;如果 primary key 這麼難選擇，選錯就會造成自己日後還得要連夜加班，有的時候不如就用 pseudokey 就好了。那具體來說 pseudokey 是什麼呢？&lt;/p&gt;

&lt;h3 id=&quot;pseudokey-surrogate-key&quot;&gt;Pseudokey (Surrogate key)&lt;/h3&gt;
&lt;p&gt;基本上是一些刻意塞給每個 row 的資料，key 本身對資料來說沒有任何意義。&lt;/p&gt;

&lt;p&gt;我們看回剛剛的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt;：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;quantity&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;banana&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 對我來說沒有什麼意義可言， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 為 2 什麼的對我來說一點意義都沒有。但是有了這個 key 以後我就不用去思考，要用哪些欄位來組合成 primary key 了。&lt;/p&gt;

&lt;p&gt;各家 DB 提供 AUTO_INCREMENT、GENERATOR 等功能來讓 pseudokey 自動增加，且多個 client 同時來 DB 塞資料也不會重複&lt;/p&gt;

&lt;p&gt;的確很常見到教材裡面，每張表都有用來放一個 id 的 primary key 欄位，會 auto increment，甚至有些 web framework 就直接這樣設計。這個慣例很不錯，但這並不是絕對的。如果有本來就有可以拿來當 primary key 的欄位，直接拿來用也無妨。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;order_id&lt;/th&gt;
      &lt;th&gt;customer&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;total&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;2020-01-01&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Carl&lt;/td&gt;
      &lt;td&gt;2020-01-01&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Carol&lt;/td&gt;
      &lt;td&gt;2020-01-06&lt;/td&gt;
      &lt;td&gt;2500&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;很多 web framework 的設計讓或書籍裡，都會讓每張表的 primary key 叫 id，然而這不是絕對的！比方說把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;products&lt;/code&gt; 這張 table 的 primary key 叫 product_id，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users&lt;/code&gt; 的叫 user_id 也挺好的。而且這種命名法還有一種優點，可以透過 &lt;strong&gt;USING&lt;/strong&gt; 來 JOIN 資料表。&lt;/p&gt;

&lt;p&gt;當 bugs 的 primary key 叫 bug_id，product 上對應的 foreign key 也叫 bug_id。 除了一般的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JOIN ... ON ...&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT * FROM bugs
JOIN bug_products ON bugs.bug_id = bug_products.bug_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;還可以改寫成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT * FROM bugs
JOIN bug_products USING(bug_id)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;問題三只有-primary-key-無法避免資料重複&quot;&gt;問題三：只有 primary key 無法避免資料重複&lt;/h2&gt;

&lt;p&gt;如果 code 沒寫好，還是有可能出現很多重複資料。比方說這個是管理訂單跟負責員工的關聯表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assignments&lt;/code&gt;：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;order_id&lt;/th&gt;
      &lt;th&gt;employee_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;330&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;330&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;331&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;除了去檢查為什麼你的 code 沒有好好地 validate 資料、避免重複，也可以檢討一下 DB 這邊沒有把 &lt;strong&gt;unique key&lt;/strong&gt; 加上去的部分。&lt;/p&gt;

&lt;p&gt;在新增 table 的時候，可以針對 order_id 和 employee_id 加上 unique key，避免出現組合重複的 order_id、employee_id：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;CREATE TABLE assignments(
   ...,
   UNIQUE(order_id,employee_id)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，直接拿 order_id 和 employee_id 組合成 compound key 來當 primary key 也是很 OK 的作法。&lt;/p&gt;

&lt;h2 id=&quot;問題四maxid-vs-last_insert_id-&quot;&gt;問題四：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX(id)&lt;/code&gt; vs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LAST_INSERT_ID() &lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;有些人會自己找 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX(id)&lt;/code&gt; (資料庫裡最大的id) 去 generate 新 id。
這樣會有 Race Condition 的問題，當多個 client 同時操作資料庫，有可能不同 client 試圖塞一樣的 id 進來。為了避免 race condition 只好做 table lock，避免同時 insert，但這樣會導致效能瓶頸。&lt;/p&gt;

&lt;p&gt;如果是用 AUTO_INCREAMENT ，MYSQL 可以用 LAST_INSERT_ID() 來取最後被 insert 進來的資料 id：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT LAST_INSERT_ID() FROM products LIMIT 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;primary key 是一種 constraint，不是一種 data type&lt;/li&gt;
  &lt;li&gt;primary key 可以是 varchar, integer 等等等，沒有一定要是 integer&lt;/li&gt;
  &lt;li&gt;primary key 可以是 auto_increment 的 pseudokey，也可以自己定義（反正 unique 就好）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像 Rails 的理念是慣例優於設定（convention over configuration），這樣的理念使得大家可以降低開發成本，善用框架本身的設計帶來的便捷功能等等。一般來說就算不需要 Rails mibgration 幫你產生的 id，你也不會特別去拿掉他。&lt;/p&gt;

&lt;p&gt;但是這可能會讓新手誤以為 primary key 就是一個叫 id、值為 integer 的欄位，其實不是這樣的。&lt;/p&gt;

&lt;p&gt;最後，附上作者的提醒：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Don’t let inflexible conventions get in the way of good design&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;補充isoiec-11179&quot;&gt;補充：ISO/IEC 11179&lt;/h2&gt;
&lt;p&gt;針對 metadata 制訂的標準，和其他標準一樣不好閱讀。Joe Celko 在他的書 SQL propgramming style 裡有實際使用這個規範。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本文是參考 Bill Karwin 的 SQL Antipatterns 第四章 ID required 彙整而成。原書說明了很多不太好的設計模式，什麼時候可以使用以及為何要避免使用等等。大家有空可以去翻閱看看哦。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>文月</name>
        
        
      </author>

      

      
        <category term="sql" />
      

      
        <summary type="html">問題一：可不可以不要 primary key？ 沒有 primary key 會怎樣？ primary key 主要的作用為：</summary>
      

      
      
    </entry>
  
</feed>
